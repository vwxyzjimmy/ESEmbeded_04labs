/**
 * 
 * STM32F4DISCOVERY
 * 
 * blink blue LED (PD15)
 * 
 */

#include <stdint.h>

#define SET_BIT(addr, bit) *((uint32_t *)(addr)) |= ((uint32_t)1 << bit)
#define CLEAR_BIT(addr, bit) *((uint32_t *)(addr)) &= ~((uint32_t)1 << bit)
#define READ_BIT(addr,bit) (((uint32_t)1 == (*(uint32_t *)(addr) & (uint32_t)1 << bit))?1:0)
//#define READ_BIT(addr,bit) *(volatile uint32_t *)(addr) &(uint32_t)1 << bit

//RCC
#define RCC_BASE 0x40023800

#define RCC_AHB1ENR_OFFSET 0x30
#define GPIODEN_BIT 3
#define GPIOAEN_BIT 0

//GPIO
#define GPIOD_BASE 0x40020C00

#define GPIOx_MODER_OFFSET 0x00
#define MODER15_1_BIT 31
#define MODER15_0_BIT 30
#define MODER14_1_BIT 29
#define MODER14_0_BIT 28
#define MODER13_1_BIT 27
#define MODER13_0_BIT 26
#define MODER12_1_BIT 25
#define MODER12_0_BIT 24

#define GPIOx_OTYPER_OFFSET 0x04
#define OT15_BIT 15
#define OT14_BIT 14
#define OT13_BIT 13
#define OT12_BIT 12

#define GPIOx_OSPEEDR_OFFSET 0x08
#define OSPEEDR15_1_BIT 31
#define OSPEEDR15_0_BIT 30
#define OSPEEDR14_1_BIT 29
#define OSPEEDR14_0_BIT 28
#define OSPEEDR13_1_BIT 27
#define OSPEEDR13_0_BIT 26
#define OSPEEDR12_1_BIT 25
#define OSPEEDR12_0_BIT 24

#define GPIOx_PUPDR_OFFSET 0x0C
#define PUPDR15_1_BIT 31
#define PUPDR15_0_BIT 30
#define PUPDR14_1_BIT 29
#define PUPDR14_0_BIT 28
#define PUPDR13_1_BIT 27
#define PUPDR13_0_BIT 26
#define PUPDR12_1_BIT 25
#define PUPDR12_0_BIT 24

#define GPIOx_BSRR_OFFSET 0x18
#define BR15_BIT 31
#define BS15_BIT 15
#define BR14_BIT 30
#define BS14_BIT 14
#define BR13_BIT 29
#define BS13_BIT 13
#define BR12_BIT 28
#define BS12_BIT 12

//GPIO_A
#define GPIOA_BASE 0x40020000

//#define GPIOx_MODER_OFFSET 0x00
#define MODER0_1_BIT 0
#define MODER0_0_BIT 1

//#define GPIOx_PUPDR_OFFSET 0x0C
#define PUPDR0_1_BIT 1
#define PUPDR0_0_BIT 0

//#define GPIOx_BSRR_OFFSET 0x18
#define BR0_BIT 16
#define BS0_BIT 0

#define GPIOx_IDR_OFFSET 0x10
#define IDR_0_BIT 0


void blink(void)
{
	SET_BIT(RCC_BASE + RCC_AHB1ENR_OFFSET, GPIODEN_BIT);
	SET_BIT(RCC_BASE + RCC_AHB1ENR_OFFSET, GPIOAEN_BIT);

	//MODER15 = 01 => General purpose output mode
	CLEAR_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER15_1_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER15_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER14_1_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER14_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER13_1_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER13_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER12_1_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_MODER_OFFSET, MODER12_0_BIT);
	
	//MODER0 = 00 => General purpose input mode
	CLEAR_BIT(GPIOA_BASE + GPIOx_MODER_OFFSET, MODER0_1_BIT);
	CLEAR_BIT(GPIOA_BASE + GPIOx_MODER_OFFSET, MODER0_0_BIT);


	//OT15 = 0 => Output push-pull
	CLEAR_BIT(GPIOD_BASE + GPIOx_OTYPER_OFFSET, OT15_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OTYPER_OFFSET, OT14_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OTYPER_OFFSET, OT13_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OTYPER_OFFSET, OT12_BIT);


	//OSPEEDR15 = 00 => Low speed
	SET_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR15_1_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR15_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR14_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR14_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR13_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR13_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR12_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_OSPEEDR_OFFSET, OSPEEDR12_0_BIT);


	//PUPDR15 = 00 => No pull-up, pull-down
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR15_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR15_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR14_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR14_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR13_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR13_0_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR12_1_BIT);
	CLEAR_BIT(GPIOD_BASE + GPIOx_PUPDR_OFFSET, PUPDR12_0_BIT);
	//PUPDR0 = 00 => No pull-up, pull-down
	CLEAR_BIT(GPIOA_BASE + GPIOx_PUPDR_OFFSET, PUPDR0_1_BIT);
	CLEAR_BIT(GPIOA_BASE + GPIOx_PUPDR_OFFSET, PUPDR0_0_BIT);
	
	SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR15_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR14_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR13_BIT);
	SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR12_BIT);
	
	unsigned int choose[] = {BS15_BIT, BS14_BIT, BS13_BIT, BS12_BIT};
	unsigned int i, light_count = 0;
	while(!READ_BIT(GPIOA_BASE + GPIOx_IDR_OFFSET, IDR_0_BIT));
	
	while (1)
	{
		if( READ_BIT(GPIOA_BASE + GPIOx_IDR_OFFSET, IDR_0_BIT)){
			while(READ_BIT(GPIOA_BASE + GPIOx_IDR_OFFSET, IDR_0_BIT));
			light_count++;
			if (light_count > 3)
				light_count = 0;
			for (i = 0; i < 10000; i++)
				;
		}

		//reset GPIOD15
		SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR15_BIT);
		SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR14_BIT);
		SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR13_BIT);
		SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, BR12_BIT);
		for (i = 0; i < 100000; i++)
			;
		SET_BIT(GPIOD_BASE + GPIOx_BSRR_OFFSET, choose[light_count]);
	
		for (i = 0; i < 100000; i++)
			;
	}
}
